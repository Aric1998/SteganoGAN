"""
This script takes in (1) the path to cover images and (2) a comma separated list of paths to 
steganographic images generated by SteganoGAN. It trains the model proposed by Ye et al. on
various subsets of paths and reports the area under the ROC curve on the validation set. 

The validation set is created at the beginning by randomly selecting 30% of the cover images 
and taking the corresponding 30% of images from one particular set of steganographic images
which we will refer to as the target set. We report the following:

  1. auROC when trainined on the target set
  2. auROC with {1, 2, 3, N-1} sets of steganographic images, excluding the target set

The former tells us how well we do when the adversary "knows" our model. The latter tells us 
how well we can do when the adversary knows the type of model, but not the specific model.
"""
import os
import argparse
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from tqdm import tqdm
from sklearn.metrics import roc_auc_score
from glob import glob
from YeNet import YeNet
from datasets import load_XY

parser = argparse.ArgumentParser(description='PyTorch implementation of YeNet')
parser.add_argument('cover', type=str)
parser.add_argument('stega', type=str)
parser.add_argument('--cuda', type=int, default=1)
parser.add_argument('--lr', type=float, default=4e-1)
parser.add_argument('--epochs', type=int, default=32)
parser.add_argument('--num_stega', type=int, default=0)
args = parser.parse_args()
args.target, *args.stega = args.stega.split(",")
print(args)

net = YeNet()
if args.cuda:
   net = net.cuda()
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adadelta(net.parameters(), lr=args.lr, rho=0.95, eps=1e-8, weight_decay=5e-4)

train_loader, valid_loader = load_XY(args)

def train(epoch):
    net.train()
    Y_true, Y_pred = [], []
    for batch_idx, data in enumerate(tqdm(train_loader)):
        images, labels = data
        if args.cuda:
            images, labels = images.cuda(), labels.cuda()
        optimizer.zero_grad()
        outputs = net(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        Y_true.extend(labels.detach().cpu().numpy().tolist())
        Y_pred.extend(F.softmax(outputs, dim=1)[:,1].detach().cpu().numpy().tolist())
    return roc_auc_score(Y_true, Y_pred)

def valid(epoch):
    net.eval()
    Y_true, Y_pred = [], []
    for batch_idx, data in enumerate(tqdm(valid_loader)):
        images, labels = data
        if args.cuda:
            images, labels = images.cuda(), labels.cuda()
        outputs = net(images)

        Y_true.extend(labels.detach().cpu().numpy().tolist())
        Y_pred.extend(F.softmax(outputs, dim=1)[:,1].detach().cpu().numpy().tolist())
    return roc_auc_score(Y_true, Y_pred)
    
for epoch in range(1, args.epochs + 1):
    train_auc = train(epoch)
    val_auc = valid(epoch)
    print(epoch, train_auc, val_auc)
